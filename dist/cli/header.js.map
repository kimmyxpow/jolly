{
  "version": 3,
  "sources": ["../node_modules/figlet/lib/figlet.js", "../node_modules/figlet/lib/node-figlet.js", "../node_modules/chalk/source/vendor/ansi-styles/index.js", "../node_modules/chalk/source/vendor/supports-color/index.js", "../node_modules/chalk/source/utilities.js", "../node_modules/chalk/source/index.js", "../src/cli/header.ts"],
  "sourcesContent": [
    "/*\n    FIGlet.js (a FIGDriver for FIGlet fonts)\n    Written by https://github.com/patorjk/figlet.js/graphs/contributors\n    Originally Written For: http://patorjk.com/software/taag/\n    License: MIT (with this header staying intact)\n\n    This JavaScript code aims to fully implement the FIGlet spec.\n    Full FIGlet spec: http://patorjk.com/software/taag/docs/figfont.txt\n\n    FIGlet fonts are actually kind of complex, which is why you will see\n    a lot of code about parsing and interpreting rules. The actual generation\n    code is pretty simple and is done near the bottom of the code.\n*/\n\n\"use strict\";\n\nconst figlet = (() => {\n  // ---------------------------------------------------------------------\n  // Private static variables\n\n  const FULL_WIDTH = 0,\n    FITTING = 1,\n    SMUSHING = 2,\n    CONTROLLED_SMUSHING = 3;\n\n  // ---------------------------------------------------------------------\n  // Variable that will hold information about the fonts\n\n  const figFonts = {}; // What stores all of the FIGlet font data\n  const figDefaults = {\n    font: \"Standard\",\n    fontPath: \"./fonts\",\n  };\n\n  // ---------------------------------------------------------------------\n  // Private static methods\n\n  /*\n        This method takes in the oldLayout and newLayout data from the FIGfont header file and returns\n        the layout information.\n    */\n  function getSmushingRules(oldLayout, newLayout) {\n    let rules = {};\n    let val, index, len, code;\n    let codes = [\n      [16384, \"vLayout\", SMUSHING],\n      [8192, \"vLayout\", FITTING],\n      [4096, \"vRule5\", true],\n      [2048, \"vRule4\", true],\n      [1024, \"vRule3\", true],\n      [512, \"vRule2\", true],\n      [256, \"vRule1\", true],\n      [128, \"hLayout\", SMUSHING],\n      [64, \"hLayout\", FITTING],\n      [32, \"hRule6\", true],\n      [16, \"hRule5\", true],\n      [8, \"hRule4\", true],\n      [4, \"hRule3\", true],\n      [2, \"hRule2\", true],\n      [1, \"hRule1\", true],\n    ];\n\n    val = newLayout !== null ? newLayout : oldLayout;\n    index = 0;\n    len = codes.length;\n    while (index < len) {\n      code = codes[index];\n      if (val >= code[0]) {\n        val = val - code[0];\n        rules[code[1]] =\n          typeof rules[code[1]] === \"undefined\" ? code[2] : rules[code[1]];\n      } else if (code[1] !== \"vLayout\" && code[1] !== \"hLayout\") {\n        rules[code[1]] = false;\n      }\n      index++;\n    }\n\n    if (typeof rules[\"hLayout\"] === \"undefined\") {\n      if (oldLayout === 0) {\n        rules[\"hLayout\"] = FITTING;\n      } else if (oldLayout === -1) {\n        rules[\"hLayout\"] = FULL_WIDTH;\n      } else {\n        if (\n          rules[\"hRule1\"] ||\n          rules[\"hRule2\"] ||\n          rules[\"hRule3\"] ||\n          rules[\"hRule4\"] ||\n          rules[\"hRule5\"] ||\n          rules[\"hRule6\"]\n        ) {\n          rules[\"hLayout\"] = CONTROLLED_SMUSHING;\n        } else {\n          rules[\"hLayout\"] = SMUSHING;\n        }\n      }\n    } else if (rules[\"hLayout\"] === SMUSHING) {\n      if (\n        rules[\"hRule1\"] ||\n        rules[\"hRule2\"] ||\n        rules[\"hRule3\"] ||\n        rules[\"hRule4\"] ||\n        rules[\"hRule5\"] ||\n        rules[\"hRule6\"]\n      ) {\n        rules[\"hLayout\"] = CONTROLLED_SMUSHING;\n      }\n    }\n\n    if (typeof rules[\"vLayout\"] === \"undefined\") {\n      if (\n        rules[\"vRule1\"] ||\n        rules[\"vRule2\"] ||\n        rules[\"vRule3\"] ||\n        rules[\"vRule4\"] ||\n        rules[\"vRule5\"]\n      ) {\n        rules[\"vLayout\"] = CONTROLLED_SMUSHING;\n      } else {\n        rules[\"vLayout\"] = FULL_WIDTH;\n      }\n    } else if (rules[\"vLayout\"] === SMUSHING) {\n      if (\n        rules[\"vRule1\"] ||\n        rules[\"vRule2\"] ||\n        rules[\"vRule3\"] ||\n        rules[\"vRule4\"] ||\n        rules[\"vRule5\"]\n      ) {\n        rules[\"vLayout\"] = CONTROLLED_SMUSHING;\n      }\n    }\n\n    return rules;\n  }\n\n  /* The [vh]Rule[1-6]_Smush functions return the smushed character OR false if the two characters can't be smushed */\n\n  /*\n        Rule 1: EQUAL CHARACTER SMUSHING (code value 1)\n\n            Two sub-characters are smushed into a single sub-character\n            if they are the same.  This rule does not smush\n            hardblanks.  (See rule 6 on hardblanks below)\n    */\n  function hRule1_Smush(ch1, ch2, hardBlank) {\n    if (ch1 === ch2 && ch1 !== hardBlank) {\n      return ch1;\n    }\n    return false;\n  }\n\n  /*\n        Rule 2: UNDERSCORE SMUSHING (code value 2)\n\n            An underscore (\"_\") will be replaced by any of: \"|\", \"/\",\n            \"\\\", \"[\", \"]\", \"{\", \"}\", \"(\", \")\", \"<\" or \">\".\n    */\n  function hRule2_Smush(ch1, ch2) {\n    let rule2Str = \"|/\\\\[]{}()<>\";\n    if (ch1 === \"_\") {\n      if (rule2Str.indexOf(ch2) !== -1) {\n        return ch2;\n      }\n    } else if (ch2 === \"_\") {\n      if (rule2Str.indexOf(ch1) !== -1) {\n        return ch1;\n      }\n    }\n    return false;\n  }\n\n  /*\n        Rule 3: HIERARCHY SMUSHING (code value 4)\n\n            A hierarchy of six classes is used: \"|\", \"/\\\", \"[]\", \"{}\",\n            \"()\", and \"<>\".  When two smushing sub-characters are\n            from different classes, the one from the latter class\n            will be used.\n    */\n  function hRule3_Smush(ch1, ch2) {\n    let rule3Classes = \"| /\\\\ [] {} () <>\";\n    let r3_pos1 = rule3Classes.indexOf(ch1);\n    let r3_pos2 = rule3Classes.indexOf(ch2);\n    if (r3_pos1 !== -1 && r3_pos2 !== -1) {\n      if (r3_pos1 !== r3_pos2 && Math.abs(r3_pos1 - r3_pos2) !== 1) {\n        const startPos = Math.max(r3_pos1, r3_pos2);\n        const endPos = startPos + 1;\n        return rule3Classes.substring(startPos, endPos);\n      }\n    }\n    return false;\n  }\n\n  /*\n        Rule 4: OPPOSITE PAIR SMUSHING (code value 8)\n\n            Smushes opposing brackets (\"[]\" or \"][\"), braces (\"{}\" or\n            \"}{\") and parentheses (\"()\" or \")(\") together, replacing\n            any such pair with a vertical bar (\"|\").\n    */\n  function hRule4_Smush(ch1, ch2) {\n    let rule4Str = \"[] {} ()\";\n    let r4_pos1 = rule4Str.indexOf(ch1);\n    let r4_pos2 = rule4Str.indexOf(ch2);\n    if (r4_pos1 !== -1 && r4_pos2 !== -1) {\n      if (Math.abs(r4_pos1 - r4_pos2) <= 1) {\n        return \"|\";\n      }\n    }\n    return false;\n  }\n\n  /*\n        Rule 5: BIG X SMUSHING (code value 16)\n\n            Smushes \"/\\\" into \"|\", \"\\/\" into \"Y\", and \"><\" into \"X\".\n            Note that \"<>\" is not smushed in any way by this rule.\n            The name \"BIG X\" is historical; originally all three pairs\n            were smushed into \"X\".\n    */\n  function hRule5_Smush(ch1, ch2) {\n    let rule5Str = \"/\\\\ \\\\/ ><\";\n    let rule5Hash = { 0: \"|\", 3: \"Y\", 6: \"X\" };\n    let r5_pos1 = rule5Str.indexOf(ch1);\n    let r5_pos2 = rule5Str.indexOf(ch2);\n    if (r5_pos1 !== -1 && r5_pos2 !== -1) {\n      if (r5_pos2 - r5_pos1 === 1) {\n        return rule5Hash[r5_pos1];\n      }\n    }\n    return false;\n  }\n\n  /*\n        Rule 6: HARDBLANK SMUSHING (code value 32)\n\n            Smushes two hardblanks together, replacing them with a\n            single hardblank.  (See \"Hardblanks\" below.)\n    */\n  function hRule6_Smush(ch1, ch2, hardBlank) {\n    if (ch1 === hardBlank && ch2 === hardBlank) {\n      return hardBlank;\n    }\n    return false;\n  }\n\n  /*\n        Rule 1: EQUAL CHARACTER SMUSHING (code value 256)\n\n            Same as horizontal smushing rule 1.\n    */\n  function vRule1_Smush(ch1, ch2) {\n    if (ch1 === ch2) {\n      return ch1;\n    }\n    return false;\n  }\n\n  /*\n        Rule 2: UNDERSCORE SMUSHING (code value 512)\n\n            Same as horizontal smushing rule 2.\n    */\n  function vRule2_Smush(ch1, ch2) {\n    let rule2Str = \"|/\\\\[]{}()<>\";\n    if (ch1 === \"_\") {\n      if (rule2Str.indexOf(ch2) !== -1) {\n        return ch2;\n      }\n    } else if (ch2 === \"_\") {\n      if (rule2Str.indexOf(ch1) !== -1) {\n        return ch1;\n      }\n    }\n    return false;\n  }\n\n  /*\n        Rule 3: HIERARCHY SMUSHING (code value 1024)\n\n            Same as horizontal smushing rule 3.\n    */\n  function vRule3_Smush(ch1, ch2) {\n    let rule3Classes = \"| /\\\\ [] {} () <>\";\n    let r3_pos1 = rule3Classes.indexOf(ch1);\n    let r3_pos2 = rule3Classes.indexOf(ch2);\n    if (r3_pos1 !== -1 && r3_pos2 !== -1) {\n      if (r3_pos1 !== r3_pos2 && Math.abs(r3_pos1 - r3_pos2) !== 1) {\n        const startPos = Math.max(r3_pos1, r3_pos2);\n        const endPos = startPos + 1;\n        return rule3Classes.substring(startPos, endPos);\n      }\n    }\n    return false;\n  }\n\n  /*\n        Rule 4: HORIZONTAL LINE SMUSHING (code value 2048)\n\n            Smushes stacked pairs of \"-\" and \"_\", replacing them with\n            a single \"=\" sub-character.  It does not matter which is\n            found above the other.  Note that vertical smushing rule 1\n            will smush IDENTICAL pairs of horizontal lines, while this\n            rule smushes horizontal lines consisting of DIFFERENT\n            sub-characters.\n    */\n  function vRule4_Smush(ch1, ch2) {\n    if ((ch1 === \"-\" && ch2 === \"_\") || (ch1 === \"_\" && ch2 === \"-\")) {\n      return \"=\";\n    }\n    return false;\n  }\n\n  /*\n        Rule 5: VERTICAL LINE SUPERSMUSHING (code value 4096)\n\n            This one rule is different from all others, in that it\n            \"supersmushes\" vertical lines consisting of several\n            vertical bars (\"|\").  This creates the illusion that\n            FIGcharacters have slid vertically against each other.\n            Supersmushing continues until any sub-characters other\n            than \"|\" would have to be smushed.  Supersmushing can\n            produce impressive results, but it is seldom possible,\n            since other sub-characters would usually have to be\n            considered for smushing as soon as any such stacked\n            vertical lines are encountered.\n    */\n  function vRule5_Smush(ch1, ch2) {\n    if (ch1 === \"|\" && ch2 === \"|\") {\n      return \"|\";\n    }\n    return false;\n  }\n\n  /*\n        Universal smushing simply overrides the sub-character from the\n        earlier FIGcharacter with the sub-character from the later\n        FIGcharacter.  This produces an \"overlapping\" effect with some\n        FIGfonts, wherin the latter FIGcharacter may appear to be \"in\n        front\".\n    */\n  function uni_Smush(ch1, ch2, hardBlank) {\n    if (ch2 === \" \" || ch2 === \"\") {\n      return ch1;\n    } else if (ch2 === hardBlank && ch1 !== \" \") {\n      return ch1;\n    } else {\n      return ch2;\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // main vertical smush routines (excluding rules)\n\n  /*\n        txt1 - A line of text\n        txt2 - A line of text\n        opts - FIGlet options array\n\n        About: Takes in two lines of text and returns one of the following:\n        \"valid\" - These lines can be smushed together given the current smushing rules\n        \"end\" - The lines can be smushed, but we're at a stopping point\n        \"invalid\" - The two lines cannot be smushed together\n    */\n  function canVerticalSmush(txt1, txt2, opts) {\n    if (opts.fittingRules.vLayout === FULL_WIDTH) {\n      return \"invalid\";\n    }\n    let ii,\n      len = Math.min(txt1.length, txt2.length),\n      ch1,\n      ch2,\n      endSmush = false,\n      validSmush;\n    if (len === 0) {\n      return \"invalid\";\n    }\n\n    for (ii = 0; ii < len; ii++) {\n      ch1 = txt1.substring(ii, ii + 1);\n      ch2 = txt2.substring(ii, ii + 1);\n      if (ch1 !== \" \" && ch2 !== \" \") {\n        if (opts.fittingRules.vLayout === FITTING) {\n          return \"invalid\";\n        } else if (opts.fittingRules.vLayout === SMUSHING) {\n          return \"end\";\n        } else {\n          if (vRule5_Smush(ch1, ch2)) {\n            endSmush = endSmush || false;\n            continue;\n          } // rule 5 allow for \"super\" smushing, but only if we're not already ending this smush\n          validSmush = false;\n          validSmush = opts.fittingRules.vRule1\n            ? vRule1_Smush(ch1, ch2)\n            : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule2\n              ? vRule2_Smush(ch1, ch2)\n              : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule3\n              ? vRule3_Smush(ch1, ch2)\n              : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule4\n              ? vRule4_Smush(ch1, ch2)\n              : validSmush;\n          endSmush = true;\n          if (!validSmush) {\n            return \"invalid\";\n          }\n        }\n      }\n    }\n    if (endSmush) {\n      return \"end\";\n    } else {\n      return \"valid\";\n    }\n  }\n\n  function getVerticalSmushDist(lines1, lines2, opts) {\n    let maxDist = lines1.length;\n    let len1 = lines1.length;\n    let len2 = lines2.length;\n    let subLines1, subLines2, slen;\n    let curDist = 1;\n    let ii, ret, result;\n    while (curDist <= maxDist) {\n      subLines1 = lines1.slice(Math.max(0, len1 - curDist), len1);\n      subLines2 = lines2.slice(0, Math.min(maxDist, curDist));\n\n      slen = subLines2.length; //TODO:check this\n      result = \"\";\n      for (ii = 0; ii < slen; ii++) {\n        ret = canVerticalSmush(subLines1[ii], subLines2[ii], opts);\n        if (ret === \"end\") {\n          result = ret;\n        } else if (ret === \"invalid\") {\n          result = ret;\n          break;\n        } else {\n          if (result === \"\") {\n            result = \"valid\";\n          }\n        }\n      }\n\n      if (result === \"invalid\") {\n        curDist--;\n        break;\n      }\n      if (result === \"end\") {\n        break;\n      }\n      if (result === \"valid\") {\n        curDist++;\n      }\n    }\n\n    return Math.min(maxDist, curDist);\n  }\n\n  function verticallySmushLines(line1, line2, opts) {\n    let ii,\n      len = Math.min(line1.length, line2.length);\n    let ch1,\n      ch2,\n      result = \"\",\n      validSmush;\n\n    for (ii = 0; ii < len; ii++) {\n      ch1 = line1.substring(ii, ii + 1);\n      ch2 = line2.substring(ii, ii + 1);\n      if (ch1 !== \" \" && ch2 !== \" \") {\n        if (opts.fittingRules.vLayout === FITTING) {\n          result += uni_Smush(ch1, ch2);\n        } else if (opts.fittingRules.vLayout === SMUSHING) {\n          result += uni_Smush(ch1, ch2);\n        } else {\n          validSmush = false;\n          validSmush = opts.fittingRules.vRule5\n            ? vRule5_Smush(ch1, ch2)\n            : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule1\n              ? vRule1_Smush(ch1, ch2)\n              : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule2\n              ? vRule2_Smush(ch1, ch2)\n              : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule3\n              ? vRule3_Smush(ch1, ch2)\n              : validSmush;\n          validSmush =\n            !validSmush && opts.fittingRules.vRule4\n              ? vRule4_Smush(ch1, ch2)\n              : validSmush;\n          result += validSmush;\n        }\n      } else {\n        result += uni_Smush(ch1, ch2);\n      }\n    }\n    return result;\n  }\n\n  function verticalSmush(lines1, lines2, overlap, opts) {\n    let len1 = lines1.length;\n    let len2 = lines2.length;\n    let piece1 = lines1.slice(0, Math.max(0, len1 - overlap));\n    let piece2_1 = lines1.slice(Math.max(0, len1 - overlap), len1);\n    let piece2_2 = lines2.slice(0, Math.min(overlap, len2));\n    let ii,\n      len,\n      line,\n      piece2 = [],\n      piece3,\n      result = [];\n\n    len = piece2_1.length;\n    for (ii = 0; ii < len; ii++) {\n      if (ii >= len2) {\n        line = piece2_1[ii];\n      } else {\n        line = verticallySmushLines(piece2_1[ii], piece2_2[ii], opts);\n      }\n      piece2.push(line);\n    }\n\n    piece3 = lines2.slice(Math.min(overlap, len2), len2);\n\n    return result.concat(piece1, piece2, piece3);\n  }\n\n  function padLines(lines, numSpaces) {\n    let ii,\n      len = lines.length,\n      padding = \"\";\n    for (ii = 0; ii < numSpaces; ii++) {\n      padding += \" \";\n    }\n    for (ii = 0; ii < len; ii++) {\n      lines[ii] += padding;\n    }\n  }\n\n  function smushVerticalFigLines(output, lines, opts) {\n    let len1 = output[0].length;\n    let len2 = lines[0].length;\n    let overlap;\n    if (len1 > len2) {\n      padLines(lines, len1 - len2);\n    } else if (len2 > len1) {\n      padLines(output, len2 - len1);\n    }\n    overlap = getVerticalSmushDist(output, lines, opts);\n    return verticalSmush(output, lines, overlap, opts);\n  }\n\n  // -------------------------------------------------------------------------\n  // Main horizontal smush routines (excluding rules)\n\n  function getHorizontalSmushLength(txt1, txt2, opts) {\n    if (opts.fittingRules.hLayout === FULL_WIDTH) {\n      return 0;\n    }\n    let ii,\n      len1 = txt1.length,\n      len2 = txt2.length;\n    let maxDist = len1;\n    let curDist = 1;\n    let breakAfter = false;\n    let validSmush = false;\n    let seg1, seg2, ch1, ch2;\n    if (len1 === 0) {\n      return 0;\n    }\n\n    distCal: while (curDist <= maxDist) {\n      const seg1StartPos = len1 - curDist;\n      seg1 = txt1.substring(seg1StartPos, seg1StartPos + curDist);\n      seg2 = txt2.substring(0, Math.min(curDist, len2));\n      for (ii = 0; ii < Math.min(curDist, len2); ii++) {\n        ch1 = seg1.substring(ii, ii + 1);\n        ch2 = seg2.substring(ii, ii + 1);\n        if (ch1 !== \" \" && ch2 !== \" \") {\n          if (opts.fittingRules.hLayout === FITTING) {\n            curDist = curDist - 1;\n            break distCal;\n          } else if (opts.fittingRules.hLayout === SMUSHING) {\n            if (ch1 === opts.hardBlank || ch2 === opts.hardBlank) {\n              curDist = curDist - 1; // universal smushing does not smush hardblanks\n            }\n            break distCal;\n          } else {\n            breakAfter = true; // we know we need to break, but we need to check if our smushing rules will allow us to smush the overlapped characters\n            validSmush = false; // the below checks will let us know if we can smush these characters\n\n            validSmush = opts.fittingRules.hRule1\n              ? hRule1_Smush(ch1, ch2, opts.hardBlank)\n              : validSmush;\n            validSmush =\n              !validSmush && opts.fittingRules.hRule2\n                ? hRule2_Smush(ch1, ch2, opts.hardBlank)\n                : validSmush;\n            validSmush =\n              !validSmush && opts.fittingRules.hRule3\n                ? hRule3_Smush(ch1, ch2, opts.hardBlank)\n                : validSmush;\n            validSmush =\n              !validSmush && opts.fittingRules.hRule4\n                ? hRule4_Smush(ch1, ch2, opts.hardBlank)\n                : validSmush;\n            validSmush =\n              !validSmush && opts.fittingRules.hRule5\n                ? hRule5_Smush(ch1, ch2, opts.hardBlank)\n                : validSmush;\n            validSmush =\n              !validSmush && opts.fittingRules.hRule6\n                ? hRule6_Smush(ch1, ch2, opts.hardBlank)\n                : validSmush;\n\n            if (!validSmush) {\n              curDist = curDist - 1;\n              break distCal;\n            }\n          }\n        }\n      }\n      if (breakAfter) {\n        break;\n      }\n      curDist++;\n    }\n    return Math.min(maxDist, curDist);\n  }\n\n  function horizontalSmush(textBlock1, textBlock2, overlap, opts) {\n    let ii,\n      jj,\n      outputFig = [],\n      overlapStart,\n      piece1,\n      piece2,\n      piece3,\n      len1,\n      len2,\n      txt1,\n      txt2;\n\n    for (ii = 0; ii < opts.height; ii++) {\n      txt1 = textBlock1[ii];\n      txt2 = textBlock2[ii];\n      len1 = txt1.length;\n      len2 = txt2.length;\n      overlapStart = len1 - overlap;\n      piece1 = txt1.substr(0, Math.max(0, overlapStart));\n      piece2 = \"\";\n\n      // determine overlap piece\n      const seg1StartPos = Math.max(0, len1 - overlap);\n      var seg1 = txt1.substring(seg1StartPos, seg1StartPos + overlap);\n      var seg2 = txt2.substring(0, Math.min(overlap, len2));\n\n      for (jj = 0; jj < overlap; jj++) {\n        var ch1 = jj < len1 ? seg1.substring(jj, jj + 1) : \" \";\n        var ch2 = jj < len2 ? seg2.substring(jj, jj + 1) : \" \";\n\n        if (ch1 !== \" \" && ch2 !== \" \") {\n          if (opts.fittingRules.hLayout === FITTING) {\n            piece2 += uni_Smush(ch1, ch2, opts.hardBlank);\n          } else if (opts.fittingRules.hLayout === SMUSHING) {\n            piece2 += uni_Smush(ch1, ch2, opts.hardBlank);\n          } else {\n            // Controlled Smushing\n            var nextCh = \"\";\n            nextCh =\n              !nextCh && opts.fittingRules.hRule1\n                ? hRule1_Smush(ch1, ch2, opts.hardBlank)\n                : nextCh;\n            nextCh =\n              !nextCh && opts.fittingRules.hRule2\n                ? hRule2_Smush(ch1, ch2, opts.hardBlank)\n                : nextCh;\n            nextCh =\n              !nextCh && opts.fittingRules.hRule3\n                ? hRule3_Smush(ch1, ch2, opts.hardBlank)\n                : nextCh;\n            nextCh =\n              !nextCh && opts.fittingRules.hRule4\n                ? hRule4_Smush(ch1, ch2, opts.hardBlank)\n                : nextCh;\n            nextCh =\n              !nextCh && opts.fittingRules.hRule5\n                ? hRule5_Smush(ch1, ch2, opts.hardBlank)\n                : nextCh;\n            nextCh =\n              !nextCh && opts.fittingRules.hRule6\n                ? hRule6_Smush(ch1, ch2, opts.hardBlank)\n                : nextCh;\n            nextCh = nextCh || uni_Smush(ch1, ch2, opts.hardBlank);\n            piece2 += nextCh;\n          }\n        } else {\n          piece2 += uni_Smush(ch1, ch2, opts.hardBlank);\n        }\n      }\n\n      if (overlap >= len2) {\n        piece3 = \"\";\n      } else {\n        piece3 = txt2.substring(overlap, overlap + Math.max(0, len2 - overlap));\n      }\n      outputFig[ii] = piece1 + piece2 + piece3;\n    }\n    return outputFig;\n  }\n\n  /*\n        Creates new empty ASCII placeholder of give len\n        - len - number\n    */\n  function newFigChar(len) {\n    let outputFigText = [],\n      row;\n    for (row = 0; row < len; row++) {\n      outputFigText[row] = \"\";\n    }\n    return outputFigText;\n  }\n\n  /*\n        Return max line of the ASCII Art\n        - text is array of lines for text\n        - char is next character\n     */\n  const figLinesWidth = function (textLines) {\n    return Math.max.apply(\n      Math,\n      textLines.map(function (line, i) {\n        return line.length;\n      })\n    );\n  };\n\n  /*\n       join words or single characaters into single Fig line\n       - array - array of ASCII words or single characters: {fig: array, overlap: number}\n       - len - height of the Characters (number of rows)\n       - opt - options object\n    */\n  function joinFigArray(array, len, opts) {\n    return array.reduce(function (acc, data) {\n      return horizontalSmush(acc, data.fig, data.overlap, opts);\n    }, newFigChar(len));\n  }\n\n  /*\n       break long word return leftover characters and line before the break\n       - figChars - list of single ASCII characters in form {fig, overlap}\n       - len - number of rows\n       - opt - options object\n    */\n  function breakWord(figChars, len, opts) {\n    const result = {};\n    for (let i = figChars.length; --i; ) {\n      let w = joinFigArray(figChars.slice(0, i), len, opts);\n      if (figLinesWidth(w) <= opts.width) {\n        result.outputFigText = w;\n        if (i < figChars.length) {\n          result.chars = figChars.slice(i);\n        } else {\n          result.chars = [];\n        }\n        break;\n      }\n    }\n    return result;\n  }\n\n  function generateFigTextLines(txt, figChars, opts) {\n    let charIndex,\n      figChar,\n      overlap = 0,\n      row,\n      outputFigText,\n      len,\n      height = opts.height,\n      outputFigLines = [],\n      maxWidth,\n      nextFigChars,\n      figWords = [],\n      char,\n      isSpace,\n      textFigWord,\n      textFigLine,\n      tmpBreak;\n\n    outputFigText = newFigChar(height);\n    if (opts.width > 0 && opts.whitespaceBreak) {\n      // list of characters is used to break in the middle of the word when word is logner\n      // chars is array of characters with {fig, overlap} and overlap is for whole word\n      nextFigChars = {\n        chars: [],\n        overlap: overlap,\n      };\n    }\n    if (opts.printDirection === 1) {\n      txt = txt.split(\"\").reverse().join(\"\");\n    }\n    len = txt.length;\n    for (charIndex = 0; charIndex < len; charIndex++) {\n      char = txt.substring(charIndex, charIndex + 1);\n      isSpace = char.match(/\\s/);\n      figChar = figChars[char.charCodeAt(0)];\n      textFigLine = null;\n      if (figChar) {\n        if (opts.fittingRules.hLayout !== FULL_WIDTH) {\n          overlap = 10000; // a value too high to be the overlap\n          for (row = 0; row < opts.height; row++) {\n            overlap = Math.min(\n              overlap,\n              getHorizontalSmushLength(outputFigText[row], figChar[row], opts)\n            );\n          }\n          overlap = overlap === 10000 ? 0 : overlap;\n        }\n        if (opts.width > 0) {\n          if (opts.whitespaceBreak) {\n            // next character in last word (figChars have same data as words)\n            textFigWord = joinFigArray(\n              nextFigChars.chars.concat([\n                {\n                  fig: figChar,\n                  overlap: overlap,\n                },\n              ]),\n              height,\n              opts\n            );\n            textFigLine = joinFigArray(\n              figWords.concat([\n                {\n                  fig: textFigWord,\n                  overlap: nextFigChars.overlap,\n                },\n              ]),\n              height,\n              opts\n            );\n            maxWidth = figLinesWidth(textFigLine);\n          } else {\n            textFigLine = horizontalSmush(\n              outputFigText,\n              figChar,\n              overlap,\n              opts\n            );\n            maxWidth = figLinesWidth(textFigLine);\n          }\n          if (maxWidth >= opts.width && charIndex > 0) {\n            if (opts.whitespaceBreak) {\n              outputFigText = joinFigArray(figWords.slice(0, -1), height, opts);\n              if (figWords.length > 1) {\n                outputFigLines.push(outputFigText);\n                outputFigText = newFigChar(height);\n              }\n              figWords = [];\n            } else {\n              outputFigLines.push(outputFigText);\n              outputFigText = newFigChar(height);\n            }\n          }\n        }\n        if (opts.width > 0 && opts.whitespaceBreak) {\n          if (!isSpace || charIndex === len - 1) {\n            nextFigChars.chars.push({ fig: figChar, overlap: overlap });\n          }\n          if (isSpace || charIndex === len - 1) {\n            // break long words\n            tmpBreak = null;\n            while (true) {\n              textFigLine = joinFigArray(nextFigChars.chars, height, opts);\n              maxWidth = figLinesWidth(textFigLine);\n              if (maxWidth >= opts.width) {\n                tmpBreak = breakWord(nextFigChars.chars, height, opts);\n                nextFigChars = { chars: tmpBreak.chars };\n                outputFigLines.push(tmpBreak.outputFigText);\n              } else {\n                break;\n              }\n            }\n            // any leftovers\n            if (maxWidth > 0) {\n              if (tmpBreak) {\n                figWords.push({ fig: textFigLine, overlap: 1 });\n              } else {\n                figWords.push({\n                  fig: textFigLine,\n                  overlap: nextFigChars.overlap,\n                });\n              }\n            }\n            // save space character and current overlap for smush in joinFigWords\n            if (isSpace) {\n              figWords.push({ fig: figChar, overlap: overlap });\n              outputFigText = newFigChar(height);\n            }\n            if (charIndex === len - 1) {\n              // last line\n              outputFigText = joinFigArray(figWords, height, opts);\n            }\n            nextFigChars = {\n              chars: [],\n              overlap: overlap,\n            };\n            continue;\n          }\n        }\n        outputFigText = horizontalSmush(outputFigText, figChar, overlap, opts);\n      }\n    }\n    // special case when last line would be empty\n    // this may happen if text fit exactly opt.width\n    if (figLinesWidth(outputFigText) > 0) {\n      outputFigLines.push(outputFigText);\n    }\n    // remove hardblanks\n    if (opts.showHardBlanks !== true) {\n      outputFigLines.forEach(function (outputFigText) {\n        len = outputFigText.length;\n        for (row = 0; row < len; row++) {\n          outputFigText[row] = outputFigText[row].replace(\n            new RegExp(\"\\\\\" + opts.hardBlank, \"g\"),\n            \" \"\n          );\n        }\n      });\n    }\n    return outputFigLines;\n  }\n\n  // -------------------------------------------------------------------------\n  // Parsing and Generation methods\n\n  const getHorizontalFittingRules = function (layout, options) {\n    let props = [\n        \"hLayout\",\n        \"hRule1\",\n        \"hRule2\",\n        \"hRule3\",\n        \"hRule4\",\n        \"hRule5\",\n        \"hRule6\",\n      ],\n      params = {},\n      ii;\n    if (layout === \"default\") {\n      for (ii = 0; ii < props.length; ii++) {\n        params[props[ii]] = options.fittingRules[props[ii]];\n      }\n    } else if (layout === \"full\") {\n      params = {\n        hLayout: FULL_WIDTH,\n        hRule1: false,\n        hRule2: false,\n        hRule3: false,\n        hRule4: false,\n        hRule5: false,\n        hRule6: false,\n      };\n    } else if (layout === \"fitted\") {\n      params = {\n        hLayout: FITTING,\n        hRule1: false,\n        hRule2: false,\n        hRule3: false,\n        hRule4: false,\n        hRule5: false,\n        hRule6: false,\n      };\n    } else if (layout === \"controlled smushing\") {\n      params = {\n        hLayout: CONTROLLED_SMUSHING,\n        hRule1: true,\n        hRule2: true,\n        hRule3: true,\n        hRule4: true,\n        hRule5: true,\n        hRule6: true,\n      };\n    } else if (layout === \"universal smushing\") {\n      params = {\n        hLayout: SMUSHING,\n        hRule1: false,\n        hRule2: false,\n        hRule3: false,\n        hRule4: false,\n        hRule5: false,\n        hRule6: false,\n      };\n    } else {\n      return;\n    }\n    return params;\n  };\n\n  const getVerticalFittingRules = function (layout, options) {\n    let props = [\"vLayout\", \"vRule1\", \"vRule2\", \"vRule3\", \"vRule4\", \"vRule5\"],\n      params = {},\n      ii;\n    if (layout === \"default\") {\n      for (ii = 0; ii < props.length; ii++) {\n        params[props[ii]] = options.fittingRules[props[ii]];\n      }\n    } else if (layout === \"full\") {\n      params = {\n        vLayout: FULL_WIDTH,\n        vRule1: false,\n        vRule2: false,\n        vRule3: false,\n        vRule4: false,\n        vRule5: false,\n      };\n    } else if (layout === \"fitted\") {\n      params = {\n        vLayout: FITTING,\n        vRule1: false,\n        vRule2: false,\n        vRule3: false,\n        vRule4: false,\n        vRule5: false,\n      };\n    } else if (layout === \"controlled smushing\") {\n      params = {\n        vLayout: CONTROLLED_SMUSHING,\n        vRule1: true,\n        vRule2: true,\n        vRule3: true,\n        vRule4: true,\n        vRule5: true,\n      };\n    } else if (layout === \"universal smushing\") {\n      params = {\n        vLayout: SMUSHING,\n        vRule1: false,\n        vRule2: false,\n        vRule3: false,\n        vRule4: false,\n        vRule5: false,\n      };\n    } else {\n      return;\n    }\n    return params;\n  };\n\n  /*\n        Generates the ASCII Art\n        - fontName: Font to use\n        - option: Options to override the defaults\n        - txt: The text to make into ASCII Art\n    */\n  const generateText = function (fontName, options, txt) {\n    txt = txt.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n    let lines = txt.split(\"\\n\");\n    let figLines = [];\n    let ii, len, output;\n    len = lines.length;\n    for (ii = 0; ii < len; ii++) {\n      figLines = figLines.concat(\n        generateFigTextLines(lines[ii], figFonts[fontName], options)\n      );\n    }\n    len = figLines.length;\n    output = figLines[0];\n    for (ii = 1; ii < len; ii++) {\n      output = smushVerticalFigLines(output, figLines[ii], options);\n    }\n\n    return output ? output.join(\"\\n\") : \"\";\n  };\n\n  /*\n      takes assigned options and merges them with the default options from the choosen font\n     */\n  function _reworkFontOpts(fontOpts, options) {\n    let myOpts = JSON.parse(JSON.stringify(fontOpts)), // make a copy because we may edit this (see below)\n      params,\n      prop;\n\n    /*\n         If the user is chosing to use a specific type of layout (e.g., 'full', 'fitted', etc etc)\n         Then we need to override the default font options.\n         */\n    if (typeof options.horizontalLayout !== \"undefined\") {\n      params = getHorizontalFittingRules(options.horizontalLayout, fontOpts);\n      for (prop in params) {\n        if (params.hasOwnProperty(prop)) {\n          myOpts.fittingRules[prop] = params[prop];\n        }\n      }\n    }\n    if (typeof options.verticalLayout !== \"undefined\") {\n      params = getVerticalFittingRules(options.verticalLayout, fontOpts);\n      for (prop in params) {\n        if (params.hasOwnProperty(prop)) {\n          myOpts.fittingRules[prop] = params[prop];\n        }\n      }\n    }\n    myOpts.printDirection =\n      typeof options.printDirection !== \"undefined\"\n        ? options.printDirection\n        : fontOpts.printDirection;\n    myOpts.showHardBlanks = options.showHardBlanks || false;\n    myOpts.width = options.width || -1;\n    myOpts.whitespaceBreak = options.whitespaceBreak || false;\n\n    return myOpts;\n  }\n\n  // -------------------------------------------------------------------------\n  // Public methods\n\n  /*\n        A short-cut for the figlet.text method\n\n        Parameters:\n        - txt (string): The text to make into ASCII Art\n        - options (object/string - optional): Options that will override the current font's default options.\n          If a string is provided instead of an object, it is assumed to be the font name.\n\n            * font\n            * horizontalLayout\n            * verticalLayout\n            * showHardBlanks - Wont remove hardblank characters\n\n        - next (function): A callback function, it will contained the outputted ASCII Art.\n    */\n  const me = function (txt, options, next) {\n    return me.text(txt, options, next);\n  };\n  me.text = async function (txt, options, next) {\n    let fontName = \"\";\n\n    // Validate inputs\n    txt = txt + \"\";\n\n    if (typeof arguments[1] === \"function\") {\n      next = options;\n      options = {};\n      options.font = figDefaults.font; // default font\n    }\n\n    if (typeof options === \"string\") {\n      fontName = options;\n      options = {};\n    } else {\n      options = options || {};\n      fontName = options.font || figDefaults.font;\n    }\n\n    return await new Promise((resolve, reject) => {\n      /*\n          Load the font. If it loads, it's data will be contained in the figFonts object.\n          The callback will recieve a fontsOpts object, which contains the default\n          options of the font (its fitting rules, etc etc).\n      */\n      me.loadFont(fontName, function (err, fontOpts) {\n        if (err) {\n          reject(err);\n          if (next) next(err);\n          return;\n        }\n\n        const generatedTxt = generateText(\n          fontName,\n          _reworkFontOpts(fontOpts, options),\n          txt\n        );\n\n        resolve(generatedTxt);\n        if (next) next(null, generatedTxt);\n      });\n    });\n  };\n\n  /*\n        Synchronous version of figlet.text.\n        Accepts the same parameters.\n     */\n  me.textSync = function (txt, options) {\n    let fontName = \"\";\n\n    // Validate inputs\n    txt = txt + \"\";\n\n    if (typeof options === \"string\") {\n      fontName = options;\n      options = {};\n    } else {\n      options = options || {};\n      fontName = options.font || figDefaults.font;\n    }\n\n    var fontOpts = _reworkFontOpts(me.loadFontSync(fontName), options);\n    return generateText(fontName, fontOpts, txt);\n  };\n\n  /*\n        Returns metadata about a specfic FIGlet font.\n\n        Returns:\n            next(err, options, headerComment)\n            - err: The error if an error occurred, otherwise null/falsey.\n            - options (object): The options defined for the font.\n            - headerComment (string): The font's header comment.\n    */\n  me.metadata = function (fontName, next) {\n    fontName = fontName + \"\";\n\n    /*\n            Load the font. If it loads, it's data will be contained in the figFonts object.\n            The callback will recieve a fontsOpts object, which contains the default\n            options of the font (its fitting rules, etc etc).\n        */\n    return new Promise(function(resolve, reject) {\n      me.loadFont(fontName, function (err, fontOpts) {\n        if (err) {\n          if (next) next(err);\n          reject(err);\n          return;\n        }\n\n        if (next) {\n          next(null, fontOpts, figFonts[fontName].comment);\n        }\n        resolve([fontOpts, figFonts[fontName].comment]);\n      });\n    });\n  };\n\n  /*\n        Allows you to override defaults. See the definition of the figDefaults object up above\n        to see what properties can be overridden.\n        Returns the options for the font.\n    */\n  me.defaults = function (opts) {\n    if (typeof opts === \"object\" && opts !== null) {\n      for (var prop in opts) {\n        if (opts.hasOwnProperty(prop)) {\n          figDefaults[prop] = opts[prop];\n        }\n      }\n    }\n    return JSON.parse(JSON.stringify(figDefaults));\n  };\n\n  /*\n        Parses data from a FIGlet font file and places it into the figFonts object.\n    */\n  me.parseFont = function (fontName, data) {\n    data = data.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n    figFonts[fontName] = {};\n\n    var lines = data.split(\"\\n\");\n    var headerData = lines.splice(0, 1)[0].split(\" \");\n    var figFont = figFonts[fontName];\n    var opts = {};\n\n    opts.hardBlank = headerData[0].substr(5, 1);\n    opts.height = parseInt(headerData[1], 10);\n    opts.baseline = parseInt(headerData[2], 10);\n    opts.maxLength = parseInt(headerData[3], 10);\n    opts.oldLayout = parseInt(headerData[4], 10);\n    opts.numCommentLines = parseInt(headerData[5], 10);\n    opts.printDirection =\n      headerData.length >= 6 ? parseInt(headerData[6], 10) : 0;\n    opts.fullLayout =\n      headerData.length >= 7 ? parseInt(headerData[7], 10) : null;\n    opts.codeTagCount =\n      headerData.length >= 8 ? parseInt(headerData[8], 10) : null;\n    opts.fittingRules = getSmushingRules(opts.oldLayout, opts.fullLayout);\n\n    figFont.options = opts;\n\n    // error check\n    if (\n      opts.hardBlank.length !== 1 ||\n      isNaN(opts.height) ||\n      isNaN(opts.baseline) ||\n      isNaN(opts.maxLength) ||\n      isNaN(opts.oldLayout) ||\n      isNaN(opts.numCommentLines)\n    ) {\n      throw new Error(\"FIGlet header contains invalid values.\");\n    }\n\n    /*\n            All FIGlet fonts must contain chars 32-126, 196, 214, 220, 228, 246, 252, 223\n        */\n\n    let charNums = [],\n      ii;\n    for (ii = 32; ii <= 126; ii++) {\n      charNums.push(ii);\n    }\n    charNums = charNums.concat(196, 214, 220, 228, 246, 252, 223);\n\n    // error check - validate that there are enough lines in the file\n    if (lines.length < opts.numCommentLines + opts.height * charNums.length) {\n      throw new Error(\"FIGlet file is missing data.\");\n    }\n\n    /*\n            Parse out the context of the file and put it into our figFont object\n        */\n\n    let cNum,\n      endCharRegEx,\n      parseError = false;\n\n    figFont.comment = lines.splice(0, opts.numCommentLines).join(\"\\n\");\n    figFont.numChars = 0;\n\n    while (lines.length > 0 && figFont.numChars < charNums.length) {\n      cNum = charNums[figFont.numChars];\n      figFont[cNum] = lines.splice(0, opts.height);\n      // remove end sub-chars\n      for (ii = 0; ii < opts.height; ii++) {\n        if (typeof figFont[cNum][ii] === \"undefined\") {\n          figFont[cNum][ii] = \"\";\n        } else {\n          endCharRegEx = new RegExp(\n            \"\\\\\" +\n              figFont[cNum][ii].substr(figFont[cNum][ii].length - 1, 1) +\n              \"+$\"\n          );\n          figFont[cNum][ii] = figFont[cNum][ii].replace(endCharRegEx, \"\");\n        }\n      }\n      figFont.numChars++;\n    }\n\n    /*\n            Now we check to see if any additional characters are present\n        */\n\n    while (lines.length > 0) {\n      cNum = lines.splice(0, 1)[0].split(\" \")[0];\n      if (/^0[xX][0-9a-fA-F]+$/.test(cNum)) {\n        cNum = parseInt(cNum, 16);\n      } else if (/^0[0-7]+$/.test(cNum)) {\n        cNum = parseInt(cNum, 8);\n      } else if (/^[0-9]+$/.test(cNum)) {\n        cNum = parseInt(cNum, 10);\n      } else if (/^-0[xX][0-9a-fA-F]+$/.test(cNum)) {\n        cNum = parseInt(cNum, 16);\n      } else {\n        if (cNum === \"\") {\n          break;\n        }\n        // something's wrong\n        console.log(\"Invalid data:\" + cNum);\n        parseError = true;\n        break;\n      }\n\n      figFont[cNum] = lines.splice(0, opts.height);\n      // remove end sub-chars\n      for (ii = 0; ii < opts.height; ii++) {\n        if (typeof figFont[cNum][ii] === \"undefined\") {\n          figFont[cNum][ii] = \"\";\n        } else {\n          endCharRegEx = new RegExp(\n            \"\\\\\" +\n              figFont[cNum][ii].substr(figFont[cNum][ii].length - 1, 1) +\n              \"+$\"\n          );\n          figFont[cNum][ii] = figFont[cNum][ii].replace(endCharRegEx, \"\");\n        }\n      }\n      figFont.numChars++;\n    }\n\n    // error check\n    if (parseError === true) {\n      throw new Error(\"Error parsing data.\");\n    }\n\n    return opts;\n  };\n\n  /*\n        Loads a font.\n    */\n  me.loadFont = function (fontName, next) {\n    if (figFonts[fontName]) {\n      if (next) {\n        next(null, figFonts[fontName].options);\n      }\n      return Promise.resolve();\n    }\n\n    if (typeof fetch !== \"function\") {\n      console.error(\n        \"figlet.js requires the fetch API or a fetch polyfill such as https://cdnjs.com/libraries/fetch\"\n      );\n      throw new Error(\"fetch is required for figlet.js to work.\");\n    }\n\n    return fetch(figDefaults.fontPath + \"/\" + fontName + \".flf\")\n      .then(function (response) {\n        if (response.ok) {\n          return response.text();\n        }\n\n        console.log(\"Unexpected response\", response);\n        throw new Error(\"Network response was not ok.\");\n      })\n      .then(function (text) {\n        if (next) {\n          next(null, me.parseFont(fontName, text));\n        }\n      })\n      .catch(next);\n  };\n\n  /*\n        loads a font synchronously, not implemented for the browser\n     */\n  me.loadFontSync = function (name) {\n    if (figFonts[name]) {\n      return figFonts[name].options;\n    }\n    throw new Error(\n      \"synchronous font loading is not implemented for the browser\"\n    );\n  };\n\n  /*\n        preloads a list of fonts prior to using textSync\n        - fonts: an array of font names (i.e. [\"Standard\",\"Soft\"])\n        - next: callback function\n     */\n  me.preloadFonts = function (fonts, next) {\n    let fontData = [];\n\n    return fonts\n      .reduce(function (promise, name) {\n        return promise.then(function () {\n          return fetch(figDefaults.fontPath + \"/\" + name + \".flf\")\n            .then((response) => {\n              return response.text();\n            })\n            .then(function (data) {\n              fontData.push(data);\n            });\n        });\n      }, Promise.resolve())\n      .then(function (res) {\n        for (var i in fonts) {\n          if (fonts.hasOwnProperty(i)) {\n            me.parseFont(fonts[i], fontData[i]);\n          }\n        }\n\n        if (next) next();\n      });\n  };\n\n  me.figFonts = figFonts;\n\n  return me;\n})();\n\n// for node.js\nif (typeof module !== \"undefined\") {\n  if (typeof module.exports !== \"undefined\") {\n    module.exports = figlet;\n  }\n}\n",
    "/*\n\tNode plugin for figlet.js\n*/\n\nconst figlet = require(\"./figlet.js\"),\n  fs = require(\"fs\"),\n  path = require(\"path\"),\n  fontDir = path.join(__dirname, \"/../fonts/\");\n\n/*\n    Loads a font into the figlet object.\n\n    Parameters:\n    - name (string): Name of the font to load.\n    - next (function): Callback function.\n*/\nfiglet.loadFont = function (name, next) {\n  return new Promise(function(resolve, reject) {\n    if (figlet.figFonts[name]) {\n      next && next(null, figlet.figFonts[name].options);\n      resolve(figlet.figFonts[name].options);\n      return;\n    }\n\n    fs.readFile(\n      path.join(fontDir, name + \".flf\"),\n      { encoding: \"utf-8\" },\n      function (err, fontData) {\n        if (err) {\n          next && next(err);\n          reject(err);\n          return;\n        }\n\n        fontData = fontData + \"\";\n        try {\n          var font = figlet.parseFont(name, fontData);\n          next && next(null, font);\n          resolve(font);\n        } catch (error) {\n          next && next(error);\n          reject(error);\n        }\n      }\n    );\n  });\n};\n\n/*\n Loads a font synchronously into the figlet object.\n\n Parameters:\n - name (string): Name of the font to load.\n */\nfiglet.loadFontSync = function (name) {\n  if (figlet.figFonts[name]) {\n    return figlet.figFonts[name].options;\n  }\n\n  var fontData = fs.readFileSync(path.join(fontDir, name + \".flf\"), {\n    encoding: \"utf-8\",\n  });\n\n  fontData = fontData + \"\";\n  return figlet.parseFont(name, fontData);\n};\n\n/*\n    Returns an array containing all of the font names\n*/\nfiglet.fonts = function (next) {\n  return new Promise(function(resolve, reject) {\n    var fontList = [];\n    fs.readdir(fontDir, function (err, files) {\n      // '/' denotes the root folder\n      if (err) {\n        next && next(err);\n        reject(err);\n        return;\n      }\n\n      files.forEach(function (file) {\n        if (/\\.flf$/.test(file)) {\n          fontList.push(file.replace(/\\.flf$/, \"\"));\n        }\n      });\n\n      next && next(null, fontList);\n      resolve(fontList);\n    });\n  });\n};\n\nfiglet.fontsSync = function () {\n  var fontList = [];\n  fs.readdirSync(fontDir).forEach(function (file) {\n    if (/\\.flf$/.test(file)) {\n      fontList.push(file.replace(/\\.flf$/, \"\"));\n    }\n  });\n\n  return fontList;\n};\n\nmodule.exports = figlet;\n",
    "const ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi16 = (offset = 0) => code => `\\u001B[${code + offset}m`;\n\nconst wrapAnsi256 = (offset = 0) => code => `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nconst styles = {\n\tmodifier: {\n\t\treset: [0, 0],\n\t\t// 21 isn't widely supported and 22 does the same thing\n\t\tbold: [1, 22],\n\t\tdim: [2, 22],\n\t\titalic: [3, 23],\n\t\tunderline: [4, 24],\n\t\toverline: [53, 55],\n\t\tinverse: [7, 27],\n\t\thidden: [8, 28],\n\t\tstrikethrough: [9, 29],\n\t},\n\tcolor: {\n\t\tblack: [30, 39],\n\t\tred: [31, 39],\n\t\tgreen: [32, 39],\n\t\tyellow: [33, 39],\n\t\tblue: [34, 39],\n\t\tmagenta: [35, 39],\n\t\tcyan: [36, 39],\n\t\twhite: [37, 39],\n\n\t\t// Bright color\n\t\tblackBright: [90, 39],\n\t\tgray: [90, 39], // Alias of `blackBright`\n\t\tgrey: [90, 39], // Alias of `blackBright`\n\t\tredBright: [91, 39],\n\t\tgreenBright: [92, 39],\n\t\tyellowBright: [93, 39],\n\t\tblueBright: [94, 39],\n\t\tmagentaBright: [95, 39],\n\t\tcyanBright: [96, 39],\n\t\twhiteBright: [97, 39],\n\t},\n\tbgColor: {\n\t\tbgBlack: [40, 49],\n\t\tbgRed: [41, 49],\n\t\tbgGreen: [42, 49],\n\t\tbgYellow: [43, 49],\n\t\tbgBlue: [44, 49],\n\t\tbgMagenta: [45, 49],\n\t\tbgCyan: [46, 49],\n\t\tbgWhite: [47, 49],\n\n\t\t// Bright color\n\t\tbgBlackBright: [100, 49],\n\t\tbgGray: [100, 49], // Alias of `bgBlackBright`\n\t\tbgGrey: [100, 49], // Alias of `bgBlackBright`\n\t\tbgRedBright: [101, 49],\n\t\tbgGreenBright: [102, 49],\n\t\tbgYellowBright: [103, 49],\n\t\tbgBlueBright: [104, 49],\n\t\tbgMagentaBright: [105, 49],\n\t\tbgCyanBright: [106, 49],\n\t\tbgWhiteBright: [107, 49],\n\t},\n};\n\nexport const modifierNames = Object.keys(styles.modifier);\nexport const foregroundColorNames = Object.keys(styles.color);\nexport const backgroundColorNames = Object.keys(styles.bgColor);\nexport const colorNames = [...foregroundColorNames, ...backgroundColorNames];\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`,\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false,\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false,\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi = wrapAnsi16();\n\tstyles.color.ansi256 = wrapAnsi256();\n\tstyles.color.ansi16m = wrapAnsi16m();\n\tstyles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n\t// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n\tObject.defineProperties(styles, {\n\t\trgbToAnsi256: {\n\t\t\tvalue(red, green, blue) {\n\t\t\t\t// We use the extended greyscale palette here, with the exception of\n\t\t\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\t\t\tif (red === green && green === blue) {\n\t\t\t\t\tif (red < 8) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (red > 248) {\n\t\t\t\t\t\treturn 231;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Math.round(((red - 8) / 247) * 24) + 232;\n\t\t\t\t}\n\n\t\t\t\treturn 16\n\t\t\t\t\t+ (36 * Math.round(red / 255 * 5))\n\t\t\t\t\t+ (6 * Math.round(green / 255 * 5))\n\t\t\t\t\t+ Math.round(blue / 255 * 5);\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t},\n\t\thexToRgb: {\n\t\t\tvalue(hex) {\n\t\t\t\tconst matches = /[a-f\\d]{6}|[a-f\\d]{3}/i.exec(hex.toString(16));\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn [0, 0, 0];\n\t\t\t\t}\n\n\t\t\t\tlet [colorString] = matches;\n\n\t\t\t\tif (colorString.length === 3) {\n\t\t\t\t\tcolorString = [...colorString].map(character => character + character).join('');\n\t\t\t\t}\n\n\t\t\t\tconst integer = Number.parseInt(colorString, 16);\n\n\t\t\t\treturn [\n\t\t\t\t\t/* eslint-disable no-bitwise */\n\t\t\t\t\t(integer >> 16) & 0xFF,\n\t\t\t\t\t(integer >> 8) & 0xFF,\n\t\t\t\t\tinteger & 0xFF,\n\t\t\t\t\t/* eslint-enable no-bitwise */\n\t\t\t\t];\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t},\n\t\thexToAnsi256: {\n\t\t\tvalue: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n\t\t\tenumerable: false,\n\t\t},\n\t\tansi256ToAnsi: {\n\t\t\tvalue(code) {\n\t\t\t\tif (code < 8) {\n\t\t\t\t\treturn 30 + code;\n\t\t\t\t}\n\n\t\t\t\tif (code < 16) {\n\t\t\t\t\treturn 90 + (code - 8);\n\t\t\t\t}\n\n\t\t\t\tlet red;\n\t\t\t\tlet green;\n\t\t\t\tlet blue;\n\n\t\t\t\tif (code >= 232) {\n\t\t\t\t\tred = (((code - 232) * 10) + 8) / 255;\n\t\t\t\t\tgreen = red;\n\t\t\t\t\tblue = red;\n\t\t\t\t} else {\n\t\t\t\t\tcode -= 16;\n\n\t\t\t\t\tconst remainder = code % 36;\n\n\t\t\t\t\tred = Math.floor(code / 36) / 5;\n\t\t\t\t\tgreen = Math.floor(remainder / 6) / 5;\n\t\t\t\t\tblue = (remainder % 6) / 5;\n\t\t\t\t}\n\n\t\t\t\tconst value = Math.max(red, green, blue) * 2;\n\n\t\t\t\tif (value === 0) {\n\t\t\t\t\treturn 30;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tlet result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));\n\n\t\t\t\tif (value === 2) {\n\t\t\t\t\tresult += 60;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t},\n\t\trgbToAnsi: {\n\t\t\tvalue: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),\n\t\t\tenumerable: false,\n\t\t},\n\t\thexToAnsi: {\n\t\t\tvalue: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),\n\t\t\tenumerable: false,\n\t\t},\n\t});\n\n\treturn styles;\n}\n\nconst ansiStyles = assembleStyles();\n\nexport default ansiStyles;\n",
    "import process from 'node:process';\nimport os from 'node:os';\nimport tty from 'node:tty';\n\n// From: https://github.com/sindresorhus/has-flag/blob/main/index.js\n/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {\nfunction hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process.argv) {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n}\n\nconst {env} = process;\n\nlet flagForceColor;\nif (\n\thasFlag('no-color')\n\t|| hasFlag('no-colors')\n\t|| hasFlag('color=false')\n\t|| hasFlag('color=never')\n) {\n\tflagForceColor = 0;\n} else if (\n\thasFlag('color')\n\t|| hasFlag('colors')\n\t|| hasFlag('color=true')\n\t|| hasFlag('color=always')\n) {\n\tflagForceColor = 1;\n}\n\nfunction envForceColor() {\n\tif ('FORCE_COLOR' in env) {\n\t\tif (env.FORCE_COLOR === 'true') {\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (env.FORCE_COLOR === 'false') {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3,\n\t};\n}\n\nfunction _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {\n\tconst noFlagForceColor = envForceColor();\n\tif (noFlagForceColor !== undefined) {\n\t\tflagForceColor = noFlagForceColor;\n\t}\n\n\tconst forceColor = sniffFlags ? flagForceColor : noFlagForceColor;\n\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (sniffFlags) {\n\t\tif (hasFlag('color=16m')\n\t\t\t|| hasFlag('color=full')\n\t\t\t|| hasFlag('color=truecolor')) {\n\t\t\treturn 3;\n\t\t}\n\n\t\tif (hasFlag('color=256')) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// Check for Azure DevOps pipelines.\n\t// Has to be above the `!streamIsTTY` check.\n\tif ('TF_BUILD' in env && 'AGENT_NAME' in env) {\n\t\treturn 1;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10\n\t\t\t&& Number(osRelease[2]) >= 10_586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14_931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {\n\t\t\treturn 3;\n\t\t}\n\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif (env.TERM === 'xterm-kitty') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app': {\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\t}\n\n\t\t\tcase 'Apple_Terminal': {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nexport function createSupportsColor(stream, options = {}) {\n\tconst level = _supportsColor(stream, {\n\t\tstreamIsTTY: stream && stream.isTTY,\n\t\t...options,\n\t});\n\n\treturn translateLevel(level);\n}\n\nconst supportsColor = {\n\tstdout: createSupportsColor({isTTY: tty.isatty(1)}),\n\tstderr: createSupportsColor({isTTY: tty.isatty(2)}),\n};\n\nexport default supportsColor;\n",
    "// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.\nexport function stringReplaceAll(string, substring, replacer) {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.slice(endIndex, index) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.slice(endIndex);\n\treturn returnValue;\n}\n\nexport function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.slice(endIndex);\n\treturn returnValue;\n}\n",
    "import ansiStyles from '#ansi-styles';\nimport supportsColor from '#supports-color';\nimport { // eslint-disable-line import/order\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex,\n} from './utilities.js';\n\nconst {stdout: stdoutColor, stderr: stderrColor} = supportsColor;\n\nconst GENERATOR = Symbol('GENERATOR');\nconst STYLER = Symbol('STYLER');\nconst IS_EMPTY = Symbol('IS_EMPTY');\n\n// `supportsColor.level`  `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m',\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nexport class Chalk {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = (...strings) => strings.join(' ');\n\tapplyOptions(chalk, options);\n\n\tObject.setPrototypeOf(chalk, createChalk.prototype);\n\n\treturn chalk;\n};\n\nfunction createChalk(options) {\n\treturn chalkFactory(options);\n}\n\nObject.setPrototypeOf(createChalk.prototype, Function.prototype);\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t},\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this[STYLER], true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t},\n};\n\nconst getModelAnsi = (model, level, type, ...arguments_) => {\n\tif (model === 'rgb') {\n\t\tif (level === 'ansi16m') {\n\t\t\treturn ansiStyles[type].ansi16m(...arguments_);\n\t\t}\n\n\t\tif (level === 'ansi256') {\n\t\t\treturn ansiStyles[type].ansi256(ansiStyles.rgbToAnsi256(...arguments_));\n\t\t}\n\n\t\treturn ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));\n\t}\n\n\tif (model === 'hex') {\n\t\treturn getModelAnsi('rgb', level, type, ...ansiStyles.hexToRgb(...arguments_));\n\t}\n\n\treturn ansiStyles[type][model](...arguments_);\n};\n\nconst usedModels = ['rgb', 'hex', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansiStyles.color.close, this[STYLER]);\n\t\t\t\treturn createBuilder(this, styler, this[IS_EMPTY]);\n\t\t\t};\n\t\t},\n\t};\n\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansiStyles.bgColor.close, this[STYLER]);\n\t\t\t\treturn createBuilder(this, styler, this[IS_EMPTY]);\n\t\t\t};\n\t\t},\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this[GENERATOR].level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis[GENERATOR].level = level;\n\t\t},\n\t},\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent,\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\t// Single argument is hot path, implicit coercion is faster than anything\n\t// eslint-disable-next-line no-implicit-coercion\n\tconst builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder[GENERATOR] = self;\n\tbuilder[STYLER] = _styler;\n\tbuilder[IS_EMPTY] = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self[IS_EMPTY] ? '' : string;\n\t}\n\n\tlet styler = self[STYLER];\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.includes('\\u001B')) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nObject.defineProperties(createChalk.prototype, styles);\n\nconst chalk = createChalk();\nexport const chalkStderr = createChalk({level: stderrColor ? stderrColor.level : 0});\n\nexport {\n\tmodifierNames,\n\tforegroundColorNames,\n\tbackgroundColorNames,\n\tcolorNames,\n\n\t// TODO: Remove these aliases in the next major version\n\tmodifierNames as modifiers,\n\tforegroundColorNames as foregroundColors,\n\tbackgroundColorNames as backgroundColors,\n\tcolorNames as colors,\n} from './vendor/ansi-styles/index.js';\n\nexport {\n\tstdoutColor as supportsColor,\n\tstderrColor as supportsColorStderr,\n};\n\nexport default chalk;\n",
    "import chalk from 'chalk';\nimport figlet from 'figlet';\n\nexport function printHeader() {\n    console.log(chalk.cyan(figlet.textSync('Jolly CLI', { horizontalLayout: 'fitted' })));\n    console.log(chalk.green('\\n\\n Welcome to the Jolly Compiler! \\n'));\n}\n"
  ],
  "mappings": "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",
  "debugId": "A4564C010EA06F9B64756E2164756E21",
  "names": []
}